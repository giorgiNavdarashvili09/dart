## რა არის ობიექტზე ორიენტირებული პროგრამირება?
აქამდე ჩვენ ვისწავლეთ თუ როგორ დავწეროთ მარტივი კლასები, შევქმნათ კლასის ცვლადები, კონსტრუქტორები და მეთოდები. როგორც უკვე ბევრჯერ ვთქვით კლასების დახმარებით ჩვენ შეგვიძლია აღვწეროთ რეალურ სამყაროში არსებული ობიექტები. ამ გზით პროგრამების შექმნას ობიექტზე ორიენტირებულ პროგრამირებას ვუწოდებთ - Object Oriented Programming (OOP). გარდა აქამდე ნასწავლი OOP_ისთან დაკავშირებული სინტაქსისა, დარტი ისევე როგორც ბევრი სხვა პროგრამირების ენა გვთავაზობს დამატებით რამდენიმე ფუნქციონალს/სინტაქსს/კონცეპტს, რომლებიც გვეხმარება უფრო ეფექტურად შევძლოთ რეალური ობიექტების აღწერა ჩვენს პროგრამებში. ერთი ასეთი ფუნქციონალი გახლავთ მემკვიდრეობა, რომელსაც ჩვენ ამ გაკვეთილში შევისწავლით.

## მემკვიდრეობა
პროცესს, როდესაც კლასი იღებს სხვა კლასის ფუნქციონალსა და მახასიათებლებს, მემკვიდრეობას(Inheritance) ვუწოდებთ. მემკვიდრეობის დახმარებით შეგვიძლია შევქმნათ კლასთა იერარქიები, სადაც შვილი კლასები იღებენ მშობელი კლასების ფუნქციონალსა და მახასიათებლებს. რთულ სიტყვებს არ მისცე უფლება დაგაბნიონ სინდამდვილეში ყველაფერი ძალიან მარტივადაა. მოდით განვიხილოთ პატარა მაგალითი.

```dart

void main() {
    Dog doggo = Dog('ბიმი');
    print(doggo.name);
}

class Animal {
    String name;

    Animal(this.name);
}


class Dog extends Animal {
    Dog(String name) : super(name);
}

```

ზემოთ მოცემულ მაგალითში Animal კლასის სინტაქსი შენთვის ნაცნობი უნდა იყოს. რაც შეეხება Dog კლასს გვაქვს ორი ახალი keyword_ი
- extends keyword დარტს ეუბნება, რომ Dog კლასი 'მემკვიდრეობით' მიიღებს Animal კლასის ცვლადებსა და ფუნქციებს (ამ შევთხვევაში Animal კლასს მხოლოდ ერთი ცვლადი აქვს).
- Animal კლასი კონსტრუქტორში ითხოვს String მონაცემის ტიპის ინფორმაციის გადაცემას. ამის გამო Dog კლასისაგან ობიექტის შექმნისას ეს მოთხოვნა უნდა დავაკმაყოფილოთ.
- Dog კლასის კონსტრუქტორის პარამეტრების შემდეგ გვაქვს : (ორი წერტილი) და super keyword_ი. super keyword_ი ამ შემთხვევაში იძახებს მშობელი კლასის(Animal) კონსტრუქტორს და გადასცემს name პარამეტრს.

ამ პროგრამის main ფუნქციაში შევქმენით doggo ობიექტი და კონსტრუქტორს გადავაწოდეთ ძაღლის სახელი ბიმი. ამის შემდეგ Dog კლასის ობიექტი მიიღებს ამ ინფორმაციას და გადააწვდის მას Animal კლასის კონსტრუქტორს. super keyword ის გამოყენებით. Animal კლასის კონსტრუქტორი საბოლოო ჯამში შეინახავს მიღებულ ინფორმაციას name ცვლადში.

მიაქცი ყურადღება, რომ Dog კლასს არ გააჩნია name ცვლადი. ამის მიუხედავად ჩვენ შევძელით Dog ტიპის ობიექტზე name პარამეტრის გამოძახება, name პარამეტრი Dog კლასმა მემკვიდრეობით მიიღო Animal კლასისაგან.

მოდით ახლა ოდნავ გავართულოთ ჩვენი მაგალითი და Animal კლასში დავამატოთ მეთოდი.

```dart

void main() {
    Dog doggo = Dog('ბიმი');
    print(doggo.name);
    doggo.makeSound();
}

class Animal {
    String name;

    Animal(this.name);

    void makeSound() {
        print('animal is making sound');
    }
}


class Dog extends Animal {
    Dog(String name) : super(name);
}

```

პროგრამის გაშვების შედეგად დაიბეჭდება:
ბიმი
animal is making sound


განახლებული მაგალითიდან შეგვიძლია მივხვდეთ, რომ კლასები მშობელი კლასებიდან, როგორც ცვლადებს ასევე მეთოდებსაც იღებენ მემკვიდრეობით.
მსგავსი მექანიზმი ზოგ შემთხვევაში გამოსადეგია, ხშირად კი შვილ კლასებში გვჭირდება მშობლის ფუნქციების ახლით შეცვლა. თუ კი Dog კლასში ჩვენ იგივე ფუნქციას აღვწერთ (იგივე დასაბრუნებელი მნიშნველობის მონაცემის ტიპი და იგივე სახელი) შეგვეძლება არსებული ფუნქციონალი ახლით შევცვალოთ. 

```dart

void main() {
    Dog doggo = Dog('ბიმი');
    print(doggo.name);
    doggo.makeSound();
}

class Animal {
    String name;

    Animal(this.name);

    void makeSound() {
        print('animal is making sound');
    }
}


class Dog extends Animal {
    Dog(String name) : super(name);

    @override
    void makeSound() {
        print('Woof Woof');
    }
}

```

ამ მაგალითში ჩვენ:
- Dog კლასში დავამატეთ makeSound მეთოდი. ამ გზით Animal კლასში არსებული იგივე სახელის მქონე მეთოდის ფუნქციონალი ახლით შევცვალეთ
- @override არის ეგრედ წოდებული ანოტაცია. დარტში ანოტაციები არ არის სავალდებულო, თუმცა ისინი ჩვენც და დარტსაც ეხმარება, რომ მარტივად მივხვდეთ, ახალ ფუნქციას ვქმნით, თუ არსებული ფუნქციის 'გადაწერას' ვცდილობთ.

ყველა კლასი რომელიც extends keyword_ის დახმარებით Animal კლასიდან მემკვიდრეობით მიიღებს makeSound მეთოდს, შეუძლია default ფუნქციონალი გამოიყენოს ან ახლით შეცვალოს. მაგალითად ქვემოთა მაგალითში ორი ახალი კლასი დავამატეთ Cat და Worm. Cat კლასი makeSound მეთოდს საკუთარი ფუნქციონალით ცვლის, Worm კლასი კი Animal კლასში აღწერილ makeSound მეთოდს იყენებს.

```dart

void main() {
    Dog doggo = Dog('ბიმი');
    doggo.makeSound(); // ბეჭდავს Woof

    Cat cat = Cat('ფისო');
    cat.makeSound(); // ბეჭდავს Meauu

    Worm worm = Worm('ჭიაყელა');
    worm.makeSound(); // ბეჭდავს animal is making sound
}

class Animal {
    String name;

    Animal(this.name);

    void makeSound() {
        print('animal is making sound');
    }
}


class Dog extends Animal {
    Dog(String name) : super(name);

    @override
    void makeSound() {
        print('Woof Woof');
    }
}

class Cat extends Animal {
    Cat(String name) : super(name);

    @override
    void makeSound() {
        print('Meauu');
    }
}

class Worm extends Animal {
    Cat(String name) : super(name);
}

```

## სხვადასხვა მონაცემის ტიპის სიები

პროგრამირებაში ხშირად არის ისეთი შემთხვევა როდესაც გვინდა ობიექტები შევინახოთ სიაში და მათზე ერთი და იგივე ოპერაცია შევასრულოთ (მაგალითად ერთი და იმავე ფუნქცია გამოვიძახოთ). ამის ერთერთი გზა სწორედ მემკვიდრეობაა. ზევით განხილული მაგალითის main ფუნქციაში შევქმნით სიას რომლის ელემენტები იქნებიან Animal ტიპის. რადგან ჩვენს მიერ შექმნილი დანარჩენი კლასები (Dog, Cat, Worm) არიან Animal კლასის შვილები, შეგვიძლია ეს ობიექტები შევინახოთ ამ სიაში.

```dart
void main() {
  Dog bimi = Dog('ბიმი');
  Dog roki = Dog('როკი');
  Dog bobi = Dog('ბობი');
  Cat fiso = Cat('ფისო');
  Cat kata = Cat('კატა');
  Cat fisunia = Cat('ფისუნია');
  Worm worm1 = Worm('ჭიაყელა');
  Worm worm2 = Worm('ჭია');
  Worm worm3 = Worm('მინიჭია');

  List<Animal> animals = [
    bimi,
    roki,
    bobi,
    fiso,
    kata,
    fisunia,
    worm1,
    worm2,
    worm3,
  ];

  for (int i = 0; i < animals.length; i++) {
    animals[i].makeSound();
  }
}

class Animal {
  String name;

  Animal(this.name);

  void makeSound() {
    print('animal is making sound');
  }
}

class Dog extends Animal {
  Dog(String name) : super(name);

  @override
  void makeSound() {
    print('$name ყეფს');
  }
}

class Cat extends Animal {
  Cat(String name) : super(name);

  @override
  void makeSound() {
    print('$name კნავის');
  }
}

class Worm extends Animal {
  Worm(String name) : super(name);
}


```

მოცემული პროგრამის გაშვების შემდეგ კონსოლში დაიბეჭდება:
ბიმი ყეფს
როკი ყეფს
ბობი ყეფს
ფისო კნავის
კატა კნავის
ფისუნია კნავის
animal is making sound
animal is making sound
animal is making sound

ამ პროგრამის main ფუნქციაში:
- შევქმენით 9 ობიექტი, 3 Dog ტიპის, 3 Cat ტიპის, 3 Worm ტიპის
- შევქმენით სია რომლის ელემენტების მონაცემის ტიპი გახლავთ Animal
- for ციკლის დახმარებით სიის ყველა ელემენტზე გამოვიძახეთ makeSound მეთოდი.

მსგავსი მაგალითები ამ კურსის განმავლობაში და ზოგადად პროგრამირებაში მრავლად შეგხვდებათ. შესაბამისად თუ ოდნავ მაინც გაუგებარია, თუ როგორ მუშაობს მოცემული კოდი, ან რაში გვჭირდება ასეთი ტიპის პროგრამების წერა, ცოტა ხანში უფრო და უფრო კარგად მივხვდებით ამას.

## Object კლასი
წინა გაკვეთილში ჩვენ ვნახეთ toString მეთოდი, რომელიც როგორც ვთქვით ყველა კლასს გააჩნია. ალბათ უკვე მიხვდი თუ რაშია საქმე. სინამდვილეში დარტის ყველა კლასი (გარდა ერთი გამონაკლისისა რომელსაც მალე შევხვდებით) მემკვიდრეობით რამდენიმე მეთოდსა და ცვლადს იღებს ერთერთი კლასიდან. ამ კლასს Object კლასი ეწოდება და ერთი ასეთი მეთოდი გახლავთ toString. 


