## რა არის ფუნქცია?

ფუნქცია არის მრავალჯერ გამოყენებადი კოდის ფრაგმენტი, რომელიც შეგვიძლია გამოვიყენოთ ჩვენს პროგრამაში სხვადსხვა ადგილიდან. ფუნქციები გვეხმარება დავყოთ პროგრამები შედარებით პატარა ბლოკებად, რაც ჩვენს პროგრამას ხდის ადვილად წასაკითხს და გასაგებს.

## როგორია ფუნქციის სინტაქსი დარტში?

```dart
return_type function_name(parameter1, parameter2, ...) {
  // ფუნქციის ტანი, შესასრულებელი ინსტრუქციები.
  return value_of_return_type; // ეს ინსტრუქცია არ არის სავალდებულო, თუ კი დასაბრუნებელი მნიშვნელობა არის void.
}

```

ზემოთ მოცემულ ფუნქციის სინტაქსში:
 - return_type - მნიშვნელობის მონაცემის ტიპი, რომელსაც ფუნქცია დააბრუნებს მაგ String, int, double, bool, void და სხვა.
 - function_name - ფუნქციის სახელი, რომლის დახმარებით შევძლებთ მის გამოძახებას. (ფუნქციის სახელს ვარჩევთ ჩვენ და უნდა ასახავდეს ფუნქციის დანიშნულებას)
 - (parameter1, parameter2, ...) - პარამეტრების დახმარებით (შეიძლება იყოს 0 ან მეტი) ფუნქციას შეგვიძლია გამოძახებისას გადავაწოდოთ გარკვეული ინფორმაცია. პარამეტრებზე მოგვიანებით ბევრს ვისაუბრებთ.
 - {} - ფუნქციის ფიგურულ ფრჩხილებში მოთავსებულია ის ინსტრუქციები, რომლებიც შესრულდება ფუნქციის გამოძახებისას
 - return value_of_return_type; - return არის დარტის სინტაქსის ნაწილი (keyword) და მიუთითებს ფუნქციის ბოლო ინსტრუქციაზე სადაც გამომძახებელს დაუბრუნდება მნიშვნელობა. (აუცილებლად უნდა იყოს იგივე მონაცემის ტიპი რაც 'return_type').

 ქვემოთ მოცემულია მარტივი ფუნქციის მაგალითი სადაც:
 - მონაცემის ტიპი void მიუთითებს, რომ ფუნქცია არ დააბრუნებს არანაირ მნიშვნელობას.
 - printHello - არის ჩემს მიერ შერჩეული ფუნქციის სახელი.
 - () მრგვალი ფრჩხილები სავალდებულოა, იმ შემთხვევაშიც, როდესაც პარამეტრები არ გვაქვს. 
 - {} ფიგურულ ფრჩხილებში მოცემული გვაქვს ერთი ინსტრუქცია.

 ```dart
void printHello() {
    print('hello');
}

```

იმისათვის, რომ ზემოთ მოცემული ფუნქცია შესრულდეს, ის უნდა 'გამოვიძახოთ' (calling function). 
ფუნქციის გამოძახებისთვის ვწერთ მის სახელს და მრგვალ გახსნის, დახურვის ფრჩხელებს. ინსტრუქციის ბოლოს ვამატებთ წერტილ-მძიმეს

 ```dart

void main() {
    print('პროგრამის დასაწყისი');
    printHello(); // ფუნქციის გამოძახება
    print('პროგრამის დასასრული');

}

void printHello() {
    print('hello');
}

```

ზემოთ მოცემულ პროგრამაში:
 - დარტი გამოიძახებს ჩვენს მიერ შექმნილ main ფუნქციას.
 - კონსოლში დაიბეჭდება 'პროგრამის დასაწყისი'
 - პროგრამა გადაინაცვლებს printHello ფუნქციაში
 - კონსოლში დაიბეჭდება 'hello'
 - პროგრამა დაბრუნდება main ფუნქციაში
 - კონსოლში დაიბეჭდება 'პროგრამის დასასრული'

## ვაწვდით ფუნქციას პარამეტრს

როგორც უკვე ვთქვით ფუნქციას შეიძლება ჰქონდეს ნოლი ან მეტი პარამეტრი. ფუნქციისთვის პარამეტრის დასამატებლად ვუთითებთ პარამეტრის მონაცემის ტიპს და პარამეტრის სახელს.

```dart
void main() {
    sayHelloTo('Giorgi'); // დაბეჭდავს hello Giorgi
    sayHelloTo('Ana'); // დაბეჭდავს hello Ana
    sayHelloTo('Nino'); // დაბეჭდავს hello Nino
}

void sayHelloTo(String name) {
    print('hello $name');
}

```

ზემოთ მოცემულ პროგრამაში:
 - შევქმენით ფუნქცია სახელად sayHelloTo
 - sayHelloTo ფუნქია არ აბრუნებს მნიშვნელობას. ამიტომ მონაცემის ტიპი გახლავთ void
 - sayHelloTo  ფუნქცია იღებს String მონაცემის ტიპის ერთ პარამეტრს სახელად name.
 - sayHelloTo ფუნქციის ტანში გვაქვს ერთი ინსტრუქცია.
 - print ფუნქციას ვაწვდით String_ს, რომელიც შედგება სიტყვა hello_სა და ფუნქციისთვის გადაწოდებული პარამეტრისგან name.
 - main ფუნქციაში ვიძახებთ sayHelloTo ფუნქციას სამჯერ სხვადასხვა პარამეტრით

## ფუნქცია აბრუნებს მნიშვნელობას

ფუნქციას ასევე შეუძლია დააბრუნოს მნიშვნელობა. ამისთვის void მონაცემის ტიპის მაგივრად ვუთითებთ დასაბრუნებელი მნიშვნელობის მონაცემის ტიპს. მაგალითად ქვემოთ მოცემული პროგრამა აბრუნებს int მონაცემის ტიპის მნიშვნელობას. რადგან ფუნქცია აბრუნებს int მონაცემის ტიპის მნიშვნელობას, შეგვიძლია შევქმნათ int ტიპის ცვლადი და ამ ცვლადს მივანიჭოთ ფუნქციის გამოძახებისას დაბრუნებული მნიშვნელობა.

```dart
void main() {
    int squareOf5 = square(5);
    print(squareOf5); // დაბეჭდავს 25_ს
}

int square(int x) {
    return x * x;
}

```

## პოზიციური პარამეტრები

აქამდე შექმნილ ფუნქციებში ჩვენ ვიყენებდით ეგრედწოდებულ პოზიციურ პარამეტრებს. ეს ნიშნავს, რომ რიგითობა, რომლითაც აღწერილია ფუნქციის პარამეტრები მისი შექმნისას, ასევე უნდა დავიცვათ მისი გამოძახებისას. ქვევით მოცემულია პროგრამის მაგალითი, სადაც ფუნქციისთვის პარამეტრების არასწორი რიგით გადაცემა გამოიწვევს არასწორ შედეგს.

```dart
void main() {
    multiply(3, 4); // დაბეჭდავს 12_ს
    multiply(4, 3); // დაბეჭდავს 12_ს

    divide(12, 3); // დაბეჭდავს 4_ს
    divide(3, 12); // 0.25_ს
}

void multiply(int a, int b) {
    print(a * b);
}

void divide(int a, int b) {
    print(a / b);
}

```

როგორც ზედა მაგალითში ვნახეთ ფუნქციის პარამეტრების რიგითობას მნიშვნელობა არ ჰქონდა multiply ფუნქციის შემთხვევაში, ხოლო divide ფუნქციისთვის პარამეტრების რიგის შეცვლით ფუნქცია განსხვავებულ შედეგს გვაძლევს. შეიძლება იფიქრო, რომ ასეთ შეცდომას არ დაუშვებ და ყოველთვის პარამეტრებს სწორი რიგით გადასცემ ფუნქციებს შენს პროგრამებში, თუმცა გაითვალისწინე, რომ ეს ისეთი მაგალითია სადაც თვალსაჩინოა და მარტივი დასანახი პარამეტრების სწორი რიგითობა. ეს ყოველთვის ასე არ არის.
ამ პრობლემის გადასაჭრელად შეგვიძლია გამოვიყენოთ ეგრედ წოდებული სახელიანი პარამეტრები.

## სახელიანი პარამეტრები

დარტში ფუნქციას პარამეტრები შეგვიძლია გადავცეთ მათი სახელის მითითებით. ამისთვის ფუნქციის შექმნისას პარამეტრების სიას ვსვავთ ფიგურულ ფრჩხილებში. ამის შემდეგ ეს პარამეტრები ასევე გახდება არა სავალდებულო, რაც ნიშნავს რომ ამ ფუნქციის გამოძახება შეგვეძლება პარამეტრების გადაცემის გარეშე. განვიხილოთ შემდეგი ფუნქცია, რომელიც სინტაქსური შეცდომის გამო არ გაეშვება:

```dart
void main() {
    greetTo();
}

void greetTo({String name}) {
    print(name: 'hello $name');
}


```

ამ პროგრამაში:
 - შევქმენით greetTo ფუნქცია
 - greetTo ფუნქციას აქვს ერთი სახელიანი, არა სავალდებულო პარამეტრი name
 - greetTo ფუნქცია კონსოლში ბეჭდავს სიტყვა hello_ს და მომხმარებლის სახელს.
 - main ფუნქციაში ვიძახებთ helloTo ფუნქციას და არ ვაწვდით პარამეტრეს. ამ ფუნქციის პარამეტრის გარეშე გამოძახება შეიძლება.

ამ ფუნქციის შექმნისას ჩვენ დარტს ვუთხარით, რომ ეს ფუნქცია მიიღებს String მონაცემის ტიპის მნიშვნელობას. მაგრამ რადგან ვიყენებთ სახელიან პარამეტრს (რომელიც არის არა სავალდებულო) ამ ფუნქციის გამოძახება შეიძლება პარამეტრის მითითების გარეშე რა დროსაც ფუნქცია დაპირებულ String მნიშვნელობას ვერ მიიღებს. ეს კი არის სინტაქსური შეცდომა და პროგრამა არ გაეშვება. ამ პრობლემის გადასაჭრელად 2 გზა შეგვიძლია გამოვიყენოთ (ჯერჯერობით)
 1. მივუთითოთ პარამეტრის default მნიშვნელობა
 2. გავხადოთ ეს პარამეტრი აუცილებელი.

ქვემოთ მოცემულ პროგრამებში ამ ორ გზას განვიხილავთ.

### default მნიშვნელობები
```dart
void main() {
    greetTo(); // დაბეჭდავს hello username
    greetTo(name: 'giorgi'); // დაბეჭდავს hello giorgi
}

void greetTo({String name = 'username'}) {
    print('hello $name');
}

```

როგორც ხედავთ პარამეტრ name_ს მივანიჭეთ default მნიშვნელობა = ოპერატორის გამოყენებით. ფუნქციის პარამეტრის გარეშე გამოძახებისას name პარამეტრი მიიღებს default მნიშვნელობა username_ს. ფუნქცია მიიღებს დაპირებულ String მნიშვნელობას და შესაბამისად აღარ გვაქვს სინდაქსური შეცდომა.


### required პარამეტრი

```dart
void main() {
    // greetTo(); ამ ფუნქციის პარამეტრის გარეშე გამოძახება არ შეიძლება
    greetTo(name: 'giorgi'); // დაბეჭდავს hello giorgi
}

void greetTo({required String name}) {
    print('hello $name');
}

```

ზემოთ მოცემულ პროგრამაში name პარამეტრი required keyword_ის დახმარებით გავხადეთ სავალდებულო, რაც იმას ნიშნავს რომ, ამ ფუნქციის გამოძახებისას აუცილებლად გადაეცემა მოთხოვნილი String მნიშვნელობა შესაბამისად სინტაქსური შეცდომა პროგრამაში აღარ იქნება. 

გაითვალისწინე, რომ სახელიანი პარამეტრების შემთხვევაში პარამეტრების რიგითობას არ აქვს მნიშვნელობა.

## ჩვენს მიერ შექმნილი პროგრამის ფუნქციების დახმარებით გადაკეთება.

წინა გაკვეთილში ჩვენ შევქმენით პროგრამა, რომელშიც სიის ელემენტებს ვამოწმებდით თუ იყო ლუწი და ასეთის არესებობის შემთხვევაში ვბეჭდავდით მათ:

 ```dart

void main() {
    List<int> numbers = [37, 52, 86, 14, 29, 63, 45, 71, 98, 23];

    for (int i = 0; i < numbers.length; i++) {
        if (numbers[i] % 2 == 0) {
            print(numbers[i]);
        }
    }

}

```
მოდით ფუნქციების დახმარებით ვცადოთ ამ პროგრამის გაუმჯობესება.

```dart

void main() {
    List<int> numbers = [37, 52, 86, 14, 29, 63, 45, 71, 98, 23];
    List<int> numbers2 = [42, 17, 89, 5, 63, 28, 10, 55, 77, 36];
    List<int> numbers3 = [91, 23, 50, 8, 37, 69, 14, 82, 45, 3];

    printEven(numbers); 
    printEven(numbers2);
    printEven(numbers3);

}

void printEven(List<int> numbers) {
    for (int i = 0; i < numbers.length; i++) {
        if (isEven(numbers[i])) {
            print(numbers[i]);
        }
    }
    print(''); // ლუწი ელემენტების შემდეგ ხაზის გამოტოვებისათვის
}


bool isEven(int number) {
    return number % 2 == 0;
}
```
ზემოთ მოცემულ პროგრამაში ჩვენ:
 - შევქმენით printEven ფუნქცია, რომეშიც 'გავიტანეთ' სიის ლუწი ელემენტების დაბეჭდვის ფუნქციონალი
 - შევქმენით isEven ფუქნცია, რომელიც ამოწმებს რიცხვი არის თუ არა ლუწი.

ჩვენი კოდის ფუნქციების დახმარებით გადაკეთების შემდეგ ჩვენი პროგრამა გახდა უფრო მოქნილი. (შეგვიძლია ერთი და იგივე ფუნქციონალი სხვადასხვა სიებისთვის გამოვიძახოთ კოდის გამეორების გარეშე.)

## სავარჯიშოები
1. შექმენი ფუქცია რომელიც პარამეტრის სახით მიიღებს ორ double ტიპის მნიშვნელობას და დააბრუნებს ამ რიცხვების ჯამს.
2. შექმენი squareTo ფუნქცია, რომელიც დაბეჭდავს რიცხვის კვადრატს. ფუნქციის პარამეტრის გარეშე გამოძახებისას დაბეჭდე 2 ის კვადრატი
3. შექმენი ფუნქცია რომელიც დაბეჭდავს 10_ზე ნაკლები რიცხვების ჯამს სიიდან. (ფუნქციამ პარამეტრად უნდა მიიღოს სია)